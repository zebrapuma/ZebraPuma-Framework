{
  "BUILD.html": {
    "href": "BUILD.html",
    "title": "DocFX Build & Preview | ZebraPuma Documentation",
    "summary": "DocFX Build & Preview Ce guide explique comment compiler et prévisualiser la documentation. Installation de DocFX # Installer DocFX globalement dotnet tool install -g docfx # Ou mettre à jour si déjà installé dotnet tool update -g docfx Génération de la Documentation Générer les métadonnées API # Depuis le répertoire docs/ docfx metadata docfx.json Cela génère les fichiers YAML dans docs/api/ à partir de vos assemblies .NET. Compiler la documentation # Compilation complète docfx build docfx.json # Compilation avec logs détaillés docfx build docfx.json --log verbose Le site est généré dans docs/_site/. Prévisualiser localement # Serveur local avec auto-refresh docfx serve docs/_site # Puis ouvrir http://localhost:8080 One-Liner: Build + Serve # Tout en une commande docfx docfx.json --serve Structure Générée docs/ ├── _site/ # Site web généré (à déployer) │ ├── index.html │ ├── articles/ │ ├── api/ │ ├── styles/ │ └── ... └── api/ # Métadonnées API (générées) ├── index.md └── *.yml Nettoyage # Supprimer les fichiers générés Remove-Item -Recurse -Force docs/_site, docs/api, docs/obj Problèmes Courants Erreur: \"No project found\" Solution: Vérifiez que vos projets sont compilés: dotnet build src/dotnet/ZebraPuma.sln --configuration Release Erreur: \"docfx not found\" Solution: Vérifiez l'installation: dotnet tool list -g Liens cassés Solution: Utilisez des chemins relatifs corrects (../index.md pour remonter d'un niveau). CI/CD Voir .github/workflows/documentation.yml pour le workflow GitHub Actions."
  },
  "api/ZebraPuma.Plugins.IPlugin.html": {
    "href": "api/ZebraPuma.Plugins.IPlugin.html",
    "title": "Interface IPlugin | ZebraPuma Documentation",
    "summary": "Interface IPlugin Namespace ZebraPuma.Plugins Assembly ZebraPuma.Plugins.dll Interface de base pour tous les plugins chargés par le système. Définit le contrat minimum que chaque plugin doit respecter. public interface IPlugin : IDisposable Inherited Members IDisposable.Dispose() Properties Description Description optionnelle du plugin. string Description { get; } Property Value string Name Nom unique du plugin. string Name { get; } Property Value string Version Version du plugin (ex: \"1.0.0\"). string Version { get; } Property Value string Methods Initialize(IPluginContext) Initialise le plugin après son chargement. Appelé automatiquement par le PluginLoader après l'instanciation. void Initialize(IPluginContext context) Parameters context IPluginContext Contexte d'initialisation contenant les informations sur l'environnement."
  },
  "api/ZebraPuma.Plugins.IPluginContext.html": {
    "href": "api/ZebraPuma.Plugins.IPluginContext.html",
    "title": "Interface IPluginContext | ZebraPuma Documentation",
    "summary": "Interface IPluginContext Namespace ZebraPuma.Plugins Assembly ZebraPuma.Plugins.dll Contexte d'initialisation fourni au plugin lors de son chargement. public interface IPluginContext Properties BaseDirectory Répertoire de base de l'application. string BaseDirectory { get; } Property Value string PluginDirectory Répertoire du plugin spécifique. string PluginDirectory { get; } Property Value string Properties Propriétés de configuration optionnelles passées au plugin. IDictionary<string, object> Properties { get; } Property Value IDictionary<string, object>"
  },
  "api/ZebraPuma.Plugins.PluginBase.html": {
    "href": "api/ZebraPuma.Plugins.PluginBase.html",
    "title": "Class PluginBase | ZebraPuma Documentation",
    "summary": "Class PluginBase Namespace ZebraPuma.Plugins Assembly ZebraPuma.Plugins.dll Classe de base abstraite pour simplifier l'implémentation de plugins. Fournit une implémentation par défaut de IPlugin avec gestion du Dispose pattern. public abstract class PluginBase : IPlugin, IDisposable Inheritance object PluginBase Implements IPlugin IDisposable Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Context Contexte d'initialisation fourni lors de l'appel à Initialize(). protected IPluginContext Context { get; } Property Value IPluginContext Description Description optionnelle du plugin. public virtual string Description { get; } Property Value string Name Nom unique du plugin. public abstract string Name { get; } Property Value string Version Version du plugin (ex: \"1.0.0\"). public virtual string Version { get; } Property Value string Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() DisposeManagedResources() Méthode protégée pour la libération des ressources managées. Override dans les classes dérivées pour libérer vos ressources. protected virtual void DisposeManagedResources() DisposeUnmanagedResources() Méthode protégée pour la libération des ressources non-managées. Override dans les classes dérivées si nécessaire. protected virtual void DisposeUnmanagedResources() ~PluginBase() protected ~PluginBase() Initialize(IPluginContext) Initialise le plugin après son chargement. Appelé automatiquement par le PluginLoader après l'instanciation. public virtual void Initialize(IPluginContext context) Parameters context IPluginContext Contexte d'initialisation contenant les informations sur l'environnement."
  },
  "api/ZebraPuma.Plugins.PluginConfigLoader.html": {
    "href": "api/ZebraPuma.Plugins.PluginConfigLoader.html",
    "title": "Class PluginConfigLoader | ZebraPuma Documentation",
    "summary": "Class PluginConfigLoader Namespace ZebraPuma.Plugins Assembly ZebraPuma.Plugins.dll public static class PluginConfigLoader Inheritance object PluginConfigLoader Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods LoadAssemblyConfig<TConfig>() Loads a JSON config file named after the assembly (lowercase) plus .json Example: EuroJapan.Api.DonKyatt.dll -> eurojapan.api.donkyatt.json The file is searched in the same directory as the assembly of TConfig. public static TConfig LoadAssemblyConfig<TConfig>() Returns TConfig Type Parameters TConfig"
  },
  "api/ZebraPuma.Plugins.PluginLoader.PluginLoadingOptions.html": {
    "href": "api/ZebraPuma.Plugins.PluginLoader.PluginLoadingOptions.html",
    "title": "Class PluginLoader.PluginLoadingOptions | ZebraPuma Documentation",
    "summary": "Class PluginLoader.PluginLoadingOptions Namespace ZebraPuma.Plugins Assembly ZebraPuma.Plugins.dll public sealed class PluginLoader.PluginLoadingOptions Inheritance object PluginLoader.PluginLoadingOptions Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() Properties AutoDiscoverOverride public bool? AutoDiscoverOverride { get; set; } Property Value bool? BaseDirectory public string BaseDirectory { get; set; } Property Value string ConfigFileName public string ConfigFileName { get; set; } Property Value string PluginsDirectoryName public string PluginsDirectoryName { get; set; } Property Value string"
  },
  "api/ZebraPuma.Plugins.PluginLoader.html": {
    "href": "api/ZebraPuma.Plugins.PluginLoader.html",
    "title": "Class PluginLoader | ZebraPuma Documentation",
    "summary": "Class PluginLoader Namespace ZebraPuma.Plugins Assembly ZebraPuma.Plugins.dll Generic plugin loader based on a plugins.json configuration file and optional auto-discovery. This is extracted from ZebraPuma.ServiceProcess.Helper to be reusable across projects. public static class PluginLoader Inheritance object PluginLoader Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods LoadPlugins<TPlugin>(PluginLoadingOptions) Charge les plugins implémentant l'interface IPlugin selon la configuration fournie. Les plugins sont automatiquement initialisés après leur instanciation. public static IReadOnlyList<TPlugin> LoadPlugins<TPlugin>(PluginLoader.PluginLoadingOptions options = null) where TPlugin : class, IPlugin Parameters options PluginLoader.PluginLoadingOptions Returns IReadOnlyList<TPlugin> Type Parameters TPlugin"
  },
  "api/ZebraPuma.Plugins.html": {
    "href": "api/ZebraPuma.Plugins.html",
    "title": "Namespace ZebraPuma.Plugins | ZebraPuma Documentation",
    "summary": "Namespace ZebraPuma.Plugins Classes PluginBase Classe de base abstraite pour simplifier l'implémentation de plugins. Fournit une implémentation par défaut de IPlugin avec gestion du Dispose pattern. PluginConfigLoader PluginLoader Generic plugin loader based on a plugins.json configuration file and optional auto-discovery. This is extracted from ZebraPuma.ServiceProcess.Helper to be reusable across projects. PluginLoader.PluginLoadingOptions Interfaces IPlugin Interface de base pour tous les plugins chargés par le système. Définit le contrat minimum que chaque plugin doit respecter. IPluginContext Contexte d'initialisation fourni au plugin lors de son chargement."
  },
  "api/ZebraPuma.System.ServiceProcess.IServiceExtended.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.IServiceExtended.html",
    "title": "Interface IServiceExtended | ZebraPuma Documentation",
    "summary": "Interface IServiceExtended Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Interface pour les services Windows extensibles basés sur le système de plugins ZebraPuma. Étend IPlugin avec des fonctionnalités de gestion de cycle de vie de service. public interface IServiceExtended : IPlugin, IDisposable Inherited Members IPlugin.Name IPlugin.Version IPlugin.Description IPlugin.Initialize(IPluginContext) IDisposable.Dispose() Properties IsRunning Indique si le service est actuellement en cours d'exécution. bool IsRunning { get; } Property Value bool Methods StartService() Démarre le service Windows. void StartService() StopService() Arrête le service Windows. void StopService()"
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceBaseExtended.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceBaseExtended.html",
    "title": "Class ServiceBaseExtended | ZebraPuma Documentation",
    "summary": "Class ServiceBaseExtended Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Classe de base abstraite pour créer des services Windows extensibles avec support de plugins. Combine ServiceBase de Windows avec IServiceExtended. Gère automatiquement le cycle de vie et la synchronisation thread-safe. public abstract class ServiceBaseExtended : ServiceBase, IComponent, IServiceExtended, IPlugin, IDisposable Inheritance object MarshalByRefObject Component ServiceBase ServiceBaseExtended Implements IComponent IServiceExtended IPlugin IDisposable Inherited Members ServiceBase.MaxNameLength ServiceBase.RequestAdditionalTime(int) ServiceBase.OnContinue() ServiceBase.OnPause() ServiceBase.OnPowerEvent(PowerBroadcastStatus) ServiceBase.OnSessionChange(SessionChangeDescription) ServiceBase.OnShutdown() ServiceBase.OnCustomCommand(int) ServiceBase.Run(ServiceBase[]) ServiceBase.Run(ServiceBase) ServiceBase.Stop() ServiceBase.AutoLog ServiceBase.ExitCode ServiceBase.CanHandlePowerEvent ServiceBase.CanHandleSessionChangeEvent ServiceBase.CanPauseAndContinue ServiceBase.CanShutdown ServiceBase.CanStop ServiceBase.EventLog ServiceBase.ServiceHandle ServiceBase.ServiceName Component.Dispose() Component.GetService(Type) Component.ToString() Component.CanRaiseEvents Component.Events Component.Site Component.Container Component.DesignMode Component.Disposed MarshalByRefObject.MemberwiseClone(bool) MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.CreateObjRef(Type) object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Description Description optionnelle du plugin. public virtual string Description { get; } Property Value string IsRunning Indique si le service est actuellement en cours d'exécution. public bool IsRunning { get; } Property Value bool Name Nom unique du plugin. public abstract string Name { get; } Property Value string Version Version du plugin (ex: \"1.0.0\"). public virtual string Version { get; } Property Value string Methods Dispose(bool) Libère les ressources utilisées par le service. Arrête automatiquement le service s'il est en cours d'exécution. protected override void Dispose(bool disposing) Parameters disposing bool True si appelé depuis Dispose(), false si appelé depuis le finaliseur. Initialize(IPluginContext) Initialise le plugin après son chargement. Appelé automatiquement par le PluginLoader après l'instanciation. public virtual void Initialize(IPluginContext context) Parameters context IPluginContext Contexte d'initialisation contenant les informations sur l'environnement. OnStart(string[]) Méthode appelée par Windows lors du démarrage du service. protected override sealed void OnStart(string[] args) Parameters args string[] Arguments de démarrage fournis par Windows. OnStartCore(string[]) Méthode à surcharger pour implémenter la logique de démarrage du service. Appelée de manière thread-safe. protected virtual void OnStartCore(string[] args) Parameters args string[] Arguments de démarrage. OnStop() Méthode appelée par Windows lors de l'arrêt du service. protected override sealed void OnStop() OnStopCore() Méthode à surcharger pour implémenter la logique d'arrêt du service. Appelée de manière thread-safe. protected virtual void OnStopCore() StartService() Démarre le service Windows. public void StartService() StopService() Arrête le service Windows. public void StopService()"
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceControllerForm.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceControllerForm.html",
    "title": "Class ServiceControllerForm | ZebraPuma Documentation",
    "summary": "Class ServiceControllerForm Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll public class ServiceControllerForm : Form, IDropTarget, ISynchronizeInvoke, IWin32Window, IBindableComponent, IComponent, IDisposable, IContainerControl Inheritance object MarshalByRefObject Component Control ScrollableControl ContainerControl Form ServiceControllerForm Implements IDropTarget ISynchronizeInvoke IWin32Window IBindableComponent IComponent IDisposable IContainerControl Inherited Members Form.SetVisibleCore(bool) Form.Activate() Form.ActivateMdiChild(Form) Form.AddOwnedForm(Form) Form.AdjustFormScrollbars(bool) Form.Close() Form.CreateControlsInstance() Form.CreateHandle() Form.DefWndProc(ref Message) Form.ProcessMnemonic(char) Form.CenterToParent() Form.CenterToScreen() Form.LayoutMdi(MdiLayout) Form.OnActivated(EventArgs) Form.OnBackgroundImageChanged(EventArgs) Form.OnBackgroundImageLayoutChanged(EventArgs) Form.OnClosing(CancelEventArgs) Form.OnClosed(EventArgs) Form.OnFormClosing(FormClosingEventArgs) Form.OnFormClosed(FormClosedEventArgs) Form.OnCreateControl() Form.OnDeactivate(EventArgs) Form.OnEnabledChanged(EventArgs) Form.OnEnter(EventArgs) Form.OnFontChanged(EventArgs) Form.OnHandleCreated(EventArgs) Form.OnHandleDestroyed(EventArgs) Form.OnHelpButtonClicked(CancelEventArgs) Form.OnLayout(LayoutEventArgs) Form.OnLoad(EventArgs) Form.OnMaximizedBoundsChanged(EventArgs) Form.OnMaximumSizeChanged(EventArgs) Form.OnMinimumSizeChanged(EventArgs) Form.OnInputLanguageChanged(InputLanguageChangedEventArgs) Form.OnInputLanguageChanging(InputLanguageChangingEventArgs) Form.OnVisibleChanged(EventArgs) Form.OnMdiChildActivate(EventArgs) Form.OnMenuStart(EventArgs) Form.OnMenuComplete(EventArgs) Form.OnPaint(PaintEventArgs) Form.OnResize(EventArgs) Form.OnDpiChanged(DpiChangedEventArgs) Form.OnGetDpiScaledSize(int, int, ref Size) Form.OnRightToLeftLayoutChanged(EventArgs) Form.OnShown(EventArgs) Form.OnTextChanged(EventArgs) Form.ProcessCmdKey(ref Message, Keys) Form.ProcessDialogKey(Keys) Form.ProcessDialogChar(char) Form.ProcessKeyPreview(ref Message) Form.ProcessTabKey(bool) Form.RemoveOwnedForm(Form) Form.Select(bool, bool) Form.GetScaledBounds(Rectangle, SizeF, BoundsSpecified) Form.ScaleControl(SizeF, BoundsSpecified) Form.SetBoundsCore(int, int, int, int, BoundsSpecified) Form.SetClientSizeCore(int, int) Form.SetDesktopBounds(int, int, int, int) Form.SetDesktopLocation(int, int) Form.Show(IWin32Window) Form.ShowDialog() Form.ShowDialog(IWin32Window) Form.ToString() Form.UpdateDefaultButton() Form.OnResizeBegin(EventArgs) Form.OnResizeEnd(EventArgs) Form.OnStyleChanged(EventArgs) Form.ValidateChildren() Form.ValidateChildren(ValidationConstraints) Form.WndProc(ref Message) Form.AcceptButton Form.ActiveForm Form.ActiveMdiChild Form.AllowTransparency Form.AutoScroll Form.AutoSize Form.AutoSizeMode Form.AutoValidate Form.BackColor Form.FormBorderStyle Form.CancelButton Form.ClientSize Form.ControlBox Form.CreateParams Form.DefaultImeMode Form.DefaultSize Form.DesktopBounds Form.DesktopLocation Form.DialogResult Form.HelpButton Form.Icon Form.IsMdiChild Form.IsMdiContainer Form.IsRestrictedWindow Form.KeyPreview Form.Location Form.MaximizedBounds Form.MaximumSize Form.MainMenuStrip Form.Menu Form.MinimumSize Form.MaximizeBox Form.MdiChildren Form.MdiParent Form.MergedMenu Form.MinimizeBox Form.Modal Form.Opacity Form.OwnedForms Form.Owner Form.RestoreBounds Form.RightToLeftLayout Form.ShowInTaskbar Form.ShowIcon Form.ShowWithoutActivation Form.Size Form.SizeGripStyle Form.StartPosition Form.Text Form.TopLevel Form.TopMost Form.TransparencyKey Form.WindowState Form.AutoSizeChanged Form.AutoValidateChanged Form.HelpButtonClicked Form.MaximizedBoundsChanged Form.MaximumSizeChanged Form.MinimumSizeChanged Form.Activated Form.Deactivate Form.FormClosing Form.FormClosed Form.Load Form.MdiChildActivate Form.MenuComplete Form.MenuStart Form.InputLanguageChanged Form.InputLanguageChanging Form.RightToLeftLayoutChanged Form.Shown Form.DpiChanged Form.ResizeBegin Form.ResizeEnd ContainerControl.OnAutoValidateChanged(EventArgs) ContainerControl.OnParentChanged(EventArgs) ContainerControl.PerformAutoScale() ContainerControl.Validate() ContainerControl.Validate(bool) ContainerControl.AutoScaleDimensions ContainerControl.AutoScaleFactor ContainerControl.AutoScaleMode ContainerControl.BindingContext ContainerControl.CanEnableIme ContainerControl.ActiveControl ContainerControl.CurrentAutoScaleDimensions ContainerControl.ParentForm ScrollableControl.ScrollStateAutoScrolling ScrollableControl.ScrollStateHScrollVisible ScrollableControl.ScrollStateVScrollVisible ScrollableControl.ScrollStateUserHasScrolled ScrollableControl.ScrollStateFullDrag ScrollableControl.GetScrollState(int) ScrollableControl.OnMouseWheel(MouseEventArgs) ScrollableControl.OnRightToLeftChanged(EventArgs) ScrollableControl.OnPaintBackground(PaintEventArgs) ScrollableControl.OnPaddingChanged(EventArgs) ScrollableControl.SetDisplayRectLocation(int, int) ScrollableControl.ScrollControlIntoView(Control) ScrollableControl.ScrollToControl(Control) ScrollableControl.OnScroll(ScrollEventArgs) ScrollableControl.SetAutoScrollMargin(int, int) ScrollableControl.SetScrollState(int, bool) ScrollableControl.AutoScrollMargin ScrollableControl.AutoScrollPosition ScrollableControl.AutoScrollMinSize ScrollableControl.DisplayRectangle ScrollableControl.HScroll ScrollableControl.HorizontalScroll ScrollableControl.VScroll ScrollableControl.VerticalScroll ScrollableControl.Scroll Control.GetAccessibilityObjectById(int) Control.SetAutoSizeMode(AutoSizeMode) Control.GetAutoSizeMode() Control.GetPreferredSize(Size) Control.AccessibilityNotifyClients(AccessibleEvents, int) Control.AccessibilityNotifyClients(AccessibleEvents, int, int) Control.BeginInvoke(Delegate) Control.BeginInvoke(Delegate, params object[]) Control.BringToFront() Control.Contains(Control) Control.CreateAccessibilityInstance() Control.CreateGraphics() Control.CreateControl() Control.DestroyHandle() Control.DoDragDrop(object, DragDropEffects) Control.DrawToBitmap(Bitmap, Rectangle) Control.EndInvoke(IAsyncResult) Control.FindForm() Control.GetTopLevel() Control.RaiseKeyEvent(object, KeyEventArgs) Control.RaiseMouseEvent(object, MouseEventArgs) Control.Focus() Control.FromChildHandle(IntPtr) Control.FromHandle(IntPtr) Control.GetChildAtPoint(Point, GetChildAtPointSkip) Control.GetChildAtPoint(Point) Control.GetContainerControl() Control.GetNextControl(Control, bool) Control.GetStyle(ControlStyles) Control.Hide() Control.InitLayout() Control.Invalidate(Region) Control.Invalidate(Region, bool) Control.Invalidate() Control.Invalidate(bool) Control.Invalidate(Rectangle) Control.Invalidate(Rectangle, bool) Control.Invoke(Delegate) Control.Invoke(Delegate, params object[]) Control.InvokePaint(Control, PaintEventArgs) Control.InvokePaintBackground(Control, PaintEventArgs) Control.IsKeyLocked(Keys) Control.IsInputChar(char) Control.IsInputKey(Keys) Control.IsMnemonic(char, string) Control.LogicalToDeviceUnits(int) Control.LogicalToDeviceUnits(Size) Control.ScaleBitmapLogicalToDevice(ref Bitmap) Control.NotifyInvalidate(Rectangle) Control.InvokeOnClick(Control, EventArgs) Control.OnAutoSizeChanged(EventArgs) Control.OnBackColorChanged(EventArgs) Control.OnBindingContextChanged(EventArgs) Control.OnCausesValidationChanged(EventArgs) Control.OnContextMenuChanged(EventArgs) Control.OnContextMenuStripChanged(EventArgs) Control.OnCursorChanged(EventArgs) Control.OnDockChanged(EventArgs) Control.OnForeColorChanged(EventArgs) Control.OnNotifyMessage(Message) Control.OnParentBackColorChanged(EventArgs) Control.OnParentBackgroundImageChanged(EventArgs) Control.OnParentBindingContextChanged(EventArgs) Control.OnParentCursorChanged(EventArgs) Control.OnParentEnabledChanged(EventArgs) Control.OnParentFontChanged(EventArgs) Control.OnParentForeColorChanged(EventArgs) Control.OnParentRightToLeftChanged(EventArgs) Control.OnParentVisibleChanged(EventArgs) Control.OnPrint(PaintEventArgs) Control.OnTabIndexChanged(EventArgs) Control.OnTabStopChanged(EventArgs) Control.OnClick(EventArgs) Control.OnClientSizeChanged(EventArgs) Control.OnControlAdded(ControlEventArgs) Control.OnControlRemoved(ControlEventArgs) Control.OnLocationChanged(EventArgs) Control.OnDoubleClick(EventArgs) Control.OnDragEnter(DragEventArgs) Control.OnDragOver(DragEventArgs) Control.OnDragLeave(EventArgs) Control.OnDragDrop(DragEventArgs) Control.OnGiveFeedback(GiveFeedbackEventArgs) Control.InvokeGotFocus(Control, EventArgs) Control.OnGotFocus(EventArgs) Control.OnHelpRequested(HelpEventArgs) Control.OnInvalidated(InvalidateEventArgs) Control.OnKeyDown(KeyEventArgs) Control.OnKeyPress(KeyPressEventArgs) Control.OnKeyUp(KeyEventArgs) Control.OnLeave(EventArgs) Control.InvokeLostFocus(Control, EventArgs) Control.OnLostFocus(EventArgs) Control.OnMarginChanged(EventArgs) Control.OnMouseDoubleClick(MouseEventArgs) Control.OnMouseClick(MouseEventArgs) Control.OnMouseCaptureChanged(EventArgs) Control.OnMouseDown(MouseEventArgs) Control.OnMouseEnter(EventArgs) Control.OnMouseLeave(EventArgs) Control.OnDpiChangedBeforeParent(EventArgs) Control.OnDpiChangedAfterParent(EventArgs) Control.OnMouseHover(EventArgs) Control.OnMouseMove(MouseEventArgs) Control.OnMouseUp(MouseEventArgs) Control.OnMove(EventArgs) Control.OnQueryContinueDrag(QueryContinueDragEventArgs) Control.OnRegionChanged(EventArgs) Control.OnPreviewKeyDown(PreviewKeyDownEventArgs) Control.OnSizeChanged(EventArgs) Control.OnChangeUICues(UICuesEventArgs) Control.OnSystemColorsChanged(EventArgs) Control.OnValidating(CancelEventArgs) Control.OnValidated(EventArgs) Control.RescaleConstantsForDpi(int, int) Control.PerformLayout() Control.PerformLayout(Control, string) Control.PointToClient(Point) Control.PointToScreen(Point) Control.PreProcessMessage(ref Message) Control.PreProcessControlMessage(ref Message) Control.ProcessKeyEventArgs(ref Message) Control.ProcessKeyMessage(ref Message) Control.RaiseDragEvent(object, DragEventArgs) Control.RaisePaintEvent(object, PaintEventArgs) Control.RecreateHandle() Control.RectangleToClient(Rectangle) Control.RectangleToScreen(Rectangle) Control.ReflectMessage(IntPtr, ref Message) Control.Refresh() Control.ResetMouseEventArgs() Control.ResetText() Control.ResumeLayout() Control.ResumeLayout(bool) Control.Scale(SizeF) Control.Select() Control.SelectNextControl(Control, bool, bool, bool, bool) Control.SendToBack() Control.SetBounds(int, int, int, int) Control.SetBounds(int, int, int, int, BoundsSpecified) Control.SizeFromClientSize(Size) Control.SetStyle(ControlStyles, bool) Control.SetTopLevel(bool) Control.RtlTranslateAlignment(HorizontalAlignment) Control.RtlTranslateAlignment(LeftRightAlignment) Control.RtlTranslateAlignment(ContentAlignment) Control.RtlTranslateHorizontal(HorizontalAlignment) Control.RtlTranslateLeftRight(LeftRightAlignment) Control.RtlTranslateContent(ContentAlignment) Control.Show() Control.SuspendLayout() Control.Update() Control.UpdateBounds() Control.UpdateBounds(int, int, int, int) Control.UpdateBounds(int, int, int, int, int, int) Control.UpdateZOrder() Control.UpdateStyles() Control.OnImeModeChanged(EventArgs) Control.AccessibilityObject Control.AccessibleDefaultActionDescription Control.AccessibleDescription Control.AccessibleName Control.AccessibleRole Control.AllowDrop Control.Anchor Control.AutoScrollOffset Control.LayoutEngine Control.BackgroundImage Control.BackgroundImageLayout Control.Bottom Control.Bounds Control.CanFocus Control.CanRaiseEvents Control.CanSelect Control.Capture Control.CausesValidation Control.CheckForIllegalCrossThreadCalls Control.ClientRectangle Control.CompanyName Control.ContainsFocus Control.ContextMenu Control.ContextMenuStrip Control.Controls Control.Created Control.Cursor Control.DataBindings Control.DefaultBackColor Control.DefaultCursor Control.DefaultFont Control.DefaultForeColor Control.DefaultMargin Control.DefaultMaximumSize Control.DefaultMinimumSize Control.DefaultPadding Control.DeviceDpi Control.IsDisposed Control.Disposing Control.Dock Control.DoubleBuffered Control.Enabled Control.Focused Control.Font Control.FontHeight Control.ForeColor Control.Handle Control.HasChildren Control.Height Control.IsHandleCreated Control.InvokeRequired Control.IsAccessible Control.IsMirrored Control.Left Control.Margin Control.ModifierKeys Control.MouseButtons Control.MousePosition Control.Name Control.Parent Control.ProductName Control.ProductVersion Control.RecreatingHandle Control.Region Control.RenderRightToLeft Control.ResizeRedraw Control.Right Control.RightToLeft Control.ScaleChildren Control.Site Control.TabIndex Control.TabStop Control.Tag Control.Top Control.TopLevelControl Control.ShowKeyboardCues Control.ShowFocusCues Control.UseWaitCursor Control.Visible Control.Width Control.PreferredSize Control.Padding Control.ImeMode Control.ImeModeBase Control.PropagatingImeMode Control.BackColorChanged Control.BackgroundImageChanged Control.BackgroundImageLayoutChanged Control.BindingContextChanged Control.CausesValidationChanged Control.ClientSizeChanged Control.ContextMenuChanged Control.ContextMenuStripChanged Control.CursorChanged Control.DockChanged Control.EnabledChanged Control.FontChanged Control.ForeColorChanged Control.LocationChanged Control.MarginChanged Control.RegionChanged Control.RightToLeftChanged Control.SizeChanged Control.TabIndexChanged Control.TabStopChanged Control.TextChanged Control.VisibleChanged Control.Click Control.ControlAdded Control.ControlRemoved Control.DragDrop Control.DragEnter Control.DragOver Control.DragLeave Control.GiveFeedback Control.HandleCreated Control.HandleDestroyed Control.HelpRequested Control.Invalidated Control.PaddingChanged Control.Paint Control.QueryContinueDrag Control.QueryAccessibilityHelp Control.DoubleClick Control.Enter Control.GotFocus Control.KeyDown Control.KeyPress Control.KeyUp Control.Layout Control.Leave Control.LostFocus Control.MouseClick Control.MouseDoubleClick Control.MouseCaptureChanged Control.MouseDown Control.MouseEnter Control.MouseLeave Control.DpiChangedBeforeParent Control.DpiChangedAfterParent Control.MouseHover Control.MouseMove Control.MouseUp Control.MouseWheel Control.Move Control.PreviewKeyDown Control.Resize Control.ChangeUICues Control.StyleChanged Control.SystemColorsChanged Control.Validating Control.Validated Control.ParentChanged Control.ImeModeChanged Component.Dispose() Component.GetService(Type) Component.Events Component.Container Component.DesignMode Component.Disposed MarshalByRefObject.MemberwiseClone(bool) MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.CreateObjRef(Type) object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Constructors ServiceControllerForm(ServiceManager) public ServiceControllerForm(ServiceManager manager) Parameters manager ServiceManager Methods Dispose(bool) Nettoyage des ressources utilisées. protected override void Dispose(bool disposing) Parameters disposing bool true si les ressources managées doivent être supprimées ; sinon, false."
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceDefinition.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceDefinition.html",
    "title": "Class ServiceDefinition | ZebraPuma Documentation",
    "summary": "Class ServiceDefinition Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Définit les métadonnées d'un service Windows pour la configuration. public class ServiceDefinition Inheritance object ServiceDefinition Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Properties Name Nom unique du service Windows. public string Name { get; set; } Property Value string Type Nom complet du type (classe) implémentant le service. public string Type { get; set; } Property Value string"
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceFactory.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceFactory.html",
    "title": "Class ServiceFactory | ZebraPuma Documentation",
    "summary": "Class ServiceFactory Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Factory pour créer et charger des services à partir d'un fichier de configuration JSON. public class ServiceFactory Inheritance object ServiceFactory Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods LoadServices(string) Charge les services définis dans un fichier de configuration JSON. public List<IServiceExtended> LoadServices(string configPath) Parameters configPath string Chemin vers le fichier de configuration JSON. Returns List<IServiceExtended> Liste des services chargés. Exceptions FileNotFoundException Si le fichier de configuration n'existe pas. JsonException Si le fichier JSON est mal formé."
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceManager.PluginLoadingOptions.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceManager.PluginLoadingOptions.html",
    "title": "Class ServiceManager.PluginLoadingOptions | ZebraPuma Documentation",
    "summary": "Class ServiceManager.PluginLoadingOptions Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Options de configuration pour le chargement des services via plugins. public sealed class ServiceManager.PluginLoadingOptions Inheritance object ServiceManager.PluginLoadingOptions Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() Properties AutoDiscoverOverride Valeur pour surcharger le flag AutoDiscover du fichier de configuration. public bool? AutoDiscoverOverride { get; set; } Property Value bool? BaseDirectory Répertoire de base. Par défaut : AppDomain.CurrentDomain.BaseDirectory public string BaseDirectory { get; set; } Property Value string ConfigFileName Nom du fichier de configuration. Par défaut : \"plugins.json\" public string ConfigFileName { get; set; } Property Value string PluginsDirectoryName Nom du dossier contenant les plugins. Par défaut : \"Plugins\" public string PluginsDirectoryName { get; set; } Property Value string"
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceManager.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceManager.html",
    "title": "Class ServiceManager | ZebraPuma Documentation",
    "summary": "Class ServiceManager Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Gestionnaire centralisé pour administrer plusieurs services Windows. Permet le démarrage, l'arrêt et le rechargement dynamique des services via plugins. public class ServiceManager : IDisposable Inheritance object ServiceManager Implements IDisposable Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Constructors ServiceManager(List<IServiceExtended>) Initialise une nouvelle instance de ServiceManager avec une liste de services. public ServiceManager(List<IServiceExtended> services) Parameters services List<IServiceExtended> La liste des services à gérer. Exceptions ArgumentNullException Si services est null. ServiceManager(IServiceExtended) Initialise une nouvelle instance de ServiceManager avec un seul service. public ServiceManager(IServiceExtended service) Parameters service IServiceExtended Le service à gérer. Exceptions ArgumentNullException Si service est null. Properties Services Obtient la liste des services gérés. public IList<IServiceExtended> Services { get; } Property Value IList<IServiceExtended> Methods CreateFromPlugins(PluginLoadingOptions) Crée un nouveau ServiceManager en chargeant les services depuis des plugins. public static ServiceManager CreateFromPlugins(ServiceManager.PluginLoadingOptions options = null) Parameters options ServiceManager.PluginLoadingOptions Options de chargement des plugins (optionnel). Returns ServiceManager Une nouvelle instance de ServiceManager avec les services chargés. Dispose() Libère les ressources utilisées par le ServiceManager. Arrête tous les services en cours d'exécution. public void Dispose() Dispose(bool) Libère les ressources managées et non-managées. protected virtual void Dispose(bool disposing) Parameters disposing bool True si appelé depuis Dispose(), false si appelé depuis le finaliseur. GetServiceNames() Obtient les noms de tous les services gérés. public IEnumerable<string> GetServiceNames() Returns IEnumerable<string> Une collection de noms de services. OnServiceStateChanged(string, bool) Déclenche l'événement ServiceStateChanged. protected virtual void OnServiceStateChanged(string name, bool isRunning) Parameters name string Le nom du service. isRunning bool True si le service est en cours d'exécution, sinon false. OnServicesReloaded() Déclenche l'événement ServicesReloaded. protected virtual void OnServicesReloaded() ReloadFromPlugins(PluginLoadingOptions) Recharge les services depuis les plugins et remplace la liste actuelle. public void ReloadFromPlugins(ServiceManager.PluginLoadingOptions options = null) Parameters options ServiceManager.PluginLoadingOptions Options de chargement des plugins (optionnel). ReplaceServices(IEnumerable<IServiceExtended>) Remplace la liste actuelle des services par une nouvelle liste. public void ReplaceServices(IEnumerable<IServiceExtended> services) Parameters services IEnumerable<IServiceExtended> La nouvelle liste de services. Exceptions ArgumentNullException Si services est null. StartAll() Démarre tous les services gérés. public void StartAll() StartService(string) Démarre un service spécifique par son nom. public void StartService(string name) Parameters name string Le nom du service à démarrer. StopAll() Arrête tous les services gérés. public void StopAll() StopService(string) Arrête un service spécifique par son nom. public void StopService(string name) Parameters name string Le nom du service à arrêter. Events ServiceStateChanged Événement déclenché lorsqu'un service change d'état (démarré/arrêté). public event EventHandler<ServiceStateChangedEventArgs> ServiceStateChanged Event Type EventHandler<ServiceStateChangedEventArgs> ServicesReloaded Événement déclenché lorsque la liste des services est rechargée. public event EventHandler ServicesReloaded Event Type EventHandler"
  },
  "api/ZebraPuma.System.ServiceProcess.ServiceStateChangedEventArgs.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.ServiceStateChangedEventArgs.html",
    "title": "Class ServiceStateChangedEventArgs | ZebraPuma Documentation",
    "summary": "Class ServiceStateChangedEventArgs Namespace ZebraPuma.System.ServiceProcess Assembly ZebraPuma.System.ServiceProcess.dll Arguments d'événement pour le changement d'état d'un service. public class ServiceStateChangedEventArgs : EventArgs Inheritance object EventArgs ServiceStateChangedEventArgs Inherited Members EventArgs.Empty object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Constructors ServiceStateChangedEventArgs(string, bool) Initialise une nouvelle instance de ServiceStateChangedEventArgs. public ServiceStateChangedEventArgs(string name, bool isRunning) Parameters name string Le nom du service. isRunning bool True si le service est en cours d'exécution. Properties IsRunning Indique si le service est en cours d'exécution. public bool IsRunning { get; } Property Value bool Name Nom du service qui a changé d'état. public string Name { get; } Property Value string"
  },
  "api/ZebraPuma.System.ServiceProcess.html": {
    "href": "api/ZebraPuma.System.ServiceProcess.html",
    "title": "Namespace ZebraPuma.System.ServiceProcess | ZebraPuma Documentation",
    "summary": "Namespace ZebraPuma.System.ServiceProcess Classes ServiceBaseExtended Classe de base abstraite pour créer des services Windows extensibles avec support de plugins. Combine ServiceBase de Windows avec IServiceExtended. Gère automatiquement le cycle de vie et la synchronisation thread-safe. ServiceControllerForm ServiceDefinition Définit les métadonnées d'un service Windows pour la configuration. ServiceFactory Factory pour créer et charger des services à partir d'un fichier de configuration JSON. ServiceManager Gestionnaire centralisé pour administrer plusieurs services Windows. Permet le démarrage, l'arrêt et le rechargement dynamique des services via plugins. ServiceManager.PluginLoadingOptions Options de configuration pour le chargement des services via plugins. ServiceStateChangedEventArgs Arguments d'événement pour le changement d'état d'un service. Interfaces IServiceExtended Interface pour les services Windows extensibles basés sur le système de plugins ZebraPuma. Étend IPlugin avec des fonctionnalités de gestion de cycle de vie de service."
  },
  "api/ZebraPuma.html": {
    "href": "api/ZebraPuma.html",
    "title": "Namespace ZebraPuma | ZebraPuma Documentation",
    "summary": "Namespace ZebraPuma Namespaces ZebraPuma.Plugins ZebraPuma.System.ServiceProcess"
  },
  "articles/plugins.html": {
    "href": "articles/plugins.html",
    "title": "ZebraPuma.Plugins | ZebraPuma Documentation",
    "summary": "ZebraPuma.Plugins Système de Plugins Modulaire avec Chargement Dynamique \uD83D\uDCCB Table des Matières Vue d'ensemble Architecture Interfaces et Classes PluginLoader Configuration Utilisation Exemples API Référence Bonnes Pratiques Vue d'ensemble ZebraPuma.Plugins est une bibliothèque de base pour créer des applications modulaires et extensibles en .NET. Elle fournit un système de plugins robuste avec chargement dynamique, auto-découverte, et gestion du cycle de vie. Caractéristiques Principales ✅ Chargement dynamique de plugins depuis DLL ✅ Auto-découverte des plugins dans les dossiers configurés ✅ Configuration JSON flexible (plugins.json) ✅ Résolution automatique des dépendances d'assemblies ✅ Gestion du cycle de vie complet (Initialize, Dispose) ✅ Support multi-frameworks (.NET Framework 4.8 et .NET 10.0) ✅ Pattern Dispose intégré pour la gestion des ressources ✅ Contexte d'initialisation avec propriétés personnalisables Cibles Supportées .NET Framework 4.8 .NET 10.0 Dépendances Newtonsoft.Json 13.0.4 NLog 6.0.7 Architecture Diagramme de Composants ┌─────────────────────────────────────────────────────────┐ │ Application Host │ │ │ │ ┌────────────────────────────────────────────────────┐ │ │ │ PluginLoader │ │ │ │ • LoadPlugins<TPlugin>() │ │ │ │ • Configuration (plugins.json) │ │ │ │ • Auto-discovery │ │ │ │ • Assembly Resolver │ │ │ └────────────────────────────────────────────────────┘ │ │ │ │ │ ▼ │ │ ┌────────────────────────────────────────────────────┐ │ │ │ IPluginContext │ │ │ │ • BaseDirectory │ │ │ │ • PluginDirectory │ │ │ │ • Properties (Dictionary) │ │ │ └────────────────────────────────────────────────────┘ │ │ │ │ └──────────────────────────┼───────────────────────────────┘ │ ┌─────────────────┴─────────────────┐ │ │ ▼ ▼ ┌─────────────────┐ ┌─────────────────┐ │ Plugin A │ │ Plugin B │ │ • IPlugin │ │ • IPlugin │ │ • Initialize() │ │ • Initialize() │ │ • Dispose() │ │ • Dispose() │ └─────────────────┘ └─────────────────┘ Flux de Chargement 1. Application démarre ↓ 2. Appel LoadPlugins<T>() ↓ 3. Lecture plugins.json (si existe) ↓ 4. Auto-discovery (si activé) ↓ 5. Résolution des chemins et assemblies ↓ 6. Activation PluginAssemblyResolver ↓ 7. Chargement Assembly.LoadFrom() ↓ 8. Création instances Activator.CreateInstance() ↓ 9. Appel Initialize(context) sur chaque plugin ↓ 10. Retour des plugins chargés Interfaces et Classes IPlugin Interface de base que tous les plugins doivent implémenter. public interface IPlugin : IDisposable { /// <summary> /// Nom unique du plugin. /// </summary> string Name { get; } /// <summary> /// Version du plugin (ex: \"1.0.0\"). /// </summary> string Version { get; } /// <summary> /// Description optionnelle du plugin. /// </summary> string Description { get; } /// <summary> /// Initialise le plugin après son chargement. /// </summary> void Initialize(IPluginContext context); } IPluginContext Contexte fourni lors de l'initialisation du plugin. public interface IPluginContext { /// <summary> /// Répertoire de base de l'application. /// </summary> string BaseDirectory { get; } /// <summary> /// Répertoire du plugin spécifique. /// </summary> string PluginDirectory { get; } /// <summary> /// Propriétés personnalisées (dictionnaire clé-valeur). /// </summary> IDictionary<string, object> Properties { get; } } PluginBase Classe de base abstraite facilitant l'implémentation de plugins avec pattern Dispose. public abstract class PluginBase : IPlugin { public abstract string Name { get; } public virtual string Version => GetType().Assembly.GetName().Version?.ToString() ?? \"1.0.0\"; public virtual string Description => string.Empty; protected IPluginContext Context { get; private set; } public virtual void Initialize(IPluginContext context) { Context = context; } protected virtual void DisposeManagedResources() { } protected virtual void DisposeUnmanagedResources() { } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { DisposeManagedResources(); } DisposeUnmanagedResources(); _disposed = true; } } } PluginLoader La classe statique PluginLoader est le point d'entrée principal pour charger les plugins. Méthode Principale public static IReadOnlyList<TPlugin> LoadPlugins<TPlugin>( PluginLoadingOptions options = null ) where TPlugin : class, IPlugin Options de Chargement public sealed class PluginLoadingOptions { /// <summary> /// Répertoire de base. Défaut: AppDomain.CurrentDomain.BaseDirectory /// </summary> public string BaseDirectory { get; set; } /// <summary> /// Nom du dossier contenant les plugins. Défaut: \"Plugins\" /// </summary> public string PluginsDirectoryName { get; set; } = \"Plugins\"; /// <summary> /// Nom du fichier de configuration. Défaut: \"plugins.json\" /// </summary> public string ConfigFileName { get; set; } = \"plugins.json\"; /// <summary> /// Override du flag AutoDiscover du fichier JSON /// </summary> public bool? AutoDiscoverOverride { get; set; } } PluginConfigLoader Utilitaire pour charger la configuration JSON d'un plugin. public static class PluginConfigLoader { /// <summary> /// Charge un fichier JSON nommé d'après l'assembly (en minuscule). /// Exemple: MonPlugin.dll -> monplugin.json /// </summary> public static TConfig LoadAssemblyConfig<TConfig>() } PluginAssemblyResolver Résout automatiquement les dépendances d'assemblies des plugins. Fonctionnement : Intercepte les événements AssemblyResolve Recherche d'abord dans le répertoire du plugin demandeur Recherche ensuite dans tous les répertoires de plugins Charge l'assembly avec Assembly.LoadFrom() Configuration Structure du fichier plugins.json { \"AutoDiscover\": true, \"Plugins\": [ { \"Folder\": \"MonPlugin\", \"Assembly\": \"MonPlugin.dll\", \"Type\": \"MonNamespace.MonPlugin\" }, { \"Folder\": \"AutrePlugin\", \"Assembly\": \"AutrePlugin.dll\", \"Type\": \"AutreNamespace.AutrePlugin\" } ] } Propriétés Propriété Type Description AutoDiscover bool Active la découverte automatique des plugins dans les sous-dossiers Plugins array Liste des plugins à charger explicitement Plugins[].Folder string Nom du sous-dossier dans le répertoire Plugins/ Plugins[].Assembly string Nom du fichier DLL Plugins[].Type string Nom complet du type (Namespace.Classe) Modes de Chargement Mode 1 : Configuration Explicite Uniquement { \"AutoDiscover\": false, \"Plugins\": [ ... ] } Charge uniquement les plugins listés. Mode 2 : Auto-Discovery Uniquement { \"AutoDiscover\": true } Scanne automatiquement tous les sous-dossiers de Plugins/. Mode 3 : Mixte (Recommandé) { \"AutoDiscover\": true, \"Plugins\": [ ... ] } Charge les plugins listés ET scanne pour d'autres plugins. Utilisation Scénario 1 : Plugin Simple Étape 1 : Créer le Plugin using ZebraPuma.Plugins; namespace MonApp.Plugins { public class MonPlugin : PluginBase { public override string Name => \"MonPlugin\"; public override string Description => \"Un plugin d'exemple\"; public override void Initialize(IPluginContext context) { base.Initialize(context); Console.WriteLine($\"Plugin initialisé dans {context.PluginDirectory}\"); } protected override void DisposeManagedResources() { Console.WriteLine(\"Nettoyage des ressources\"); } } } Étape 2 : Compiler et Déployer # Compiler le plugin dotnet build MonPlugin.csproj # Créer le dossier de déploiement mkdir AppHost\\Plugins\\MonPlugin # Copier la DLL copy bin\\Debug\\net10.0\\MonPlugin.dll AppHost\\Plugins\\MonPlugin\\ Étape 3 : Configurer (optionnel) Créer AppHost/plugins.json : { \"AutoDiscover\": true } Étape 4 : Charger dans l'Application using ZebraPuma.Plugins; class Program { static void Main() { var plugins = PluginLoader.LoadPlugins<IPlugin>(); foreach (var plugin in plugins) { Console.WriteLine($\"Plugin: {plugin.Name} v{plugin.Version}\"); Console.WriteLine($\"Description: {plugin.Description}\"); } // Cleanup foreach (var plugin in plugins) { plugin.Dispose(); } } } Scénario 2 : Plugin avec Configuration Configuration du Plugin (monplugin.json) { \"DatabaseConnection\": \"Server=localhost;Database=test;\", \"MaxRetries\": 3, \"EnableLogging\": true } Classe de Configuration public class MonPluginConfig { public string DatabaseConnection { get; set; } public int MaxRetries { get; set; } public bool EnableLogging { get; set; } } Plugin avec Configuration public class MonPlugin : PluginBase { private MonPluginConfig _config; public override string Name => \"MonPlugin\"; public override void Initialize(IPluginContext context) { base.Initialize(context); // Charger la configuration _config = PluginConfigLoader.LoadAssemblyConfig<MonPluginConfig>(); if (_config.EnableLogging) { Console.WriteLine($\"Connexion: {_config.DatabaseConnection}\"); } } } Scénario 3 : Interface de Plugin Personnalisée // Définir une interface spécialisée public interface IDataProcessor : IPlugin { void ProcessData(string input); string GetResult(); } // Implémenter l'interface public class CsvProcessor : PluginBase, IDataProcessor { private string _result; public override string Name => \"CsvProcessor\"; public void ProcessData(string input) { _result = $\"Processed: {input}\"; } public string GetResult() => _result; } // Charger uniquement les plugins de ce type var processors = PluginLoader.LoadPlugins<IDataProcessor>(); foreach (var processor in processors) { processor.ProcessData(\"test.csv\"); Console.WriteLine(processor.GetResult()); } Exemples Exemple 1 : Application Console Multi-Plugins using System; using System.Collections.Generic; using ZebraPuma.Plugins; namespace PluginHost { class Program { static void Main(string[] args) { Console.WriteLine(\"=== Plugin Host ===\\n\"); var options = new PluginLoader.PluginLoadingOptions { PluginsDirectoryName = \"Plugins\", ConfigFileName = \"plugins.json\", AutoDiscoverOverride = true }; var plugins = PluginLoader.LoadPlugins<IPlugin>(options); Console.WriteLine($\"Chargé {plugins.Count} plugin(s):\\n\"); foreach (var plugin in plugins) { Console.WriteLine($\" • {plugin.Name}\"); Console.WriteLine($\" Version: {plugin.Version}\"); Console.WriteLine($\" Description: {plugin.Description}\\n\"); } Console.WriteLine(\"Appuyez sur une touche pour terminer...\"); Console.ReadKey(); // Cleanup foreach (var plugin in plugins) { plugin.Dispose(); } } } } Exemple 2 : Plugin avec Logging NLog using NLog; using ZebraPuma.Plugins; public class LoggingPlugin : PluginBase { private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); public override string Name => \"LoggingPlugin\"; public override void Initialize(IPluginContext context) { base.Initialize(context); Logger.Info(\"Plugin {Name} initialisé\", Name); Logger.Debug(\"BaseDirectory: {Dir}\", context.BaseDirectory); Logger.Debug(\"PluginDirectory: {Dir}\", context.PluginDirectory); } protected override void DisposeManagedResources() { Logger.Info(\"Plugin {Name} en cours de fermeture\", Name); } } Exemple 3 : Structure de Projet Complète MonApplication/ ├── MonApplication.csproj ├── Program.cs ├── plugins.json ├── NLog.config ├── Plugins/ │ ├── PluginA/ │ │ ├── PluginA.dll │ │ ├── PluginA.pdb │ │ ├── plugina.json │ │ └── dependance.dll │ ├── PluginB/ │ │ ├── PluginB.dll │ │ ├── PluginB.pdb │ │ └── pluginb.json │ └── PluginC/ │ └── PluginC.dll └── logs/ └── {date}.log plugins.json { \"AutoDiscover\": true, \"Plugins\": [ { \"Folder\": \"PluginA\", \"Assembly\": \"PluginA.dll\", \"Type\": \"MonApp.Plugins.PluginA\" } ] } API Référence Namespace: ZebraPuma.Plugins Classes Classe Description PluginBase Classe de base abstraite pour plugins PluginLoader Chargeur de plugins statique PluginConfigLoader Utilitaire pour charger config JSON Interfaces Interface Description IPlugin Contrat de base pour tous les plugins IPluginContext Contexte d'initialisation Types Type Description PluginLoadingOptions Options de chargement de plugins Bonnes Pratiques 1. Nommage et Versioning ✅ Bon public class DataExportPlugin : PluginBase { public override string Name => \"DataExportPlugin\"; public override string Version => \"2.1.0\"; public override string Description => \"Exporte les données au format CSV et JSON\"; } ❌ Mauvais public class Plugin1 : PluginBase { public override string Name => \"p1\"; public override string Version => \"1\"; } 2. Gestion des Ressources ✅ Bon public class DatabasePlugin : PluginBase { private SqlConnection _connection; public override void Initialize(IPluginContext context) { base.Initialize(context); _connection = new SqlConnection(connectionString); _connection.Open(); } protected override void DisposeManagedResources() { _connection?.Close(); _connection?.Dispose(); } } ❌ Mauvais (fuite de ressources) public class DatabasePlugin : PluginBase { private SqlConnection _connection; public override void Initialize(IPluginContext context) { _connection = new SqlConnection(connectionString); _connection.Open(); // Pas de Dispose! } } 3. Gestion d'Erreurs ✅ Bon public override void Initialize(IPluginContext context) { try { base.Initialize(context); var config = PluginConfigLoader.LoadAssemblyConfig<Config>(); // ... initialisation } catch (FileNotFoundException ex) { Logger.Error(ex, \"Fichier de configuration introuvable\"); throw new PluginInitializationException(\"Config manquante\", ex); } catch (Exception ex) { Logger.Fatal(ex, \"Erreur critique d'initialisation\"); throw; } } 4. Configuration ✅ Bon - Configuration typée public class MyPluginConfig { [JsonProperty(\"connectionString\")] public string ConnectionString { get; set; } [JsonProperty(\"timeout\")] public int Timeout { get; set; } = 30; } var config = PluginConfigLoader.LoadAssemblyConfig<MyPluginConfig>(); ❌ Mauvais - Configuration en dur const string connectionString = \"Server=localhost;...\"; 5. Dépendances ✅ Bon - Dépendances dans le dossier du plugin Plugins/ MonPlugin/ MonPlugin.dll Newtonsoft.Json.dll NLog.dll ❌ Mauvais - Dépendances manquantes Plugins/ MonPlugin/ MonPlugin.dll // Newtonsoft.Json.dll manquant -> Crash! 6. Thread Safety ✅ Bon public class ThreadSafePlugin : PluginBase { private readonly object _lock = new object(); private int _counter; public void IncrementCounter() { lock (_lock) { _counter++; } } } 7. Logging ✅ Bon private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); public override void Initialize(IPluginContext context) { Logger.Info(\"Initialisation de {Plugin} v{Version}\", Name, Version); Logger.Debug(\"Context: {@Context}\", context); try { // ... code Logger.Info(\"Initialisation réussie\"); } catch (Exception ex) { Logger.Error(ex, \"Échec d'initialisation\"); throw; } } Troubleshooting Problème : Plugin Non Chargé Symptôme : Le plugin n'apparaît pas dans la liste Solutions : Vérifier plugins.json existe et est bien formé Vérifier AutoDiscover est true ou plugin est listé Vérifier le chemin Folder et Assembly Vérifier que la classe implémente IPlugin Consulter les logs NLog Problème : FileNotFoundException Symptôme : Exception lors du chargement Solutions : Vérifier que toutes les DLL sont présentes Copier les dépendances dans le dossier du plugin Utiliser Fusion Log Viewer pour diagnostiquer Vérifier les versions de .NET Problème : InvalidCastException Symptôme : Erreur de cast lors du chargement Solutions : Vérifier que le plugin implémente l'interface demandée Vérifier la signature where TPlugin : class, IPlugin Reconstruire le plugin avec les bonnes références Performance Recommandations Cache des plugins : Ne pas recharger à chaque utilisation Lazy loading : Charger uniquement quand nécessaire Dispose : Toujours libérer les ressources Assembly resolver : Dispose du resolver quand terminé Métriques Typiques Opération Temps Moyen Chargement 1 plugin 50-100 ms Chargement 10 plugins 300-500 ms Initialize d'un plugin 10-50 ms ⬅️ Retour à la documentation principale"
  },
  "articles/serviceprocess.html": {
    "href": "articles/serviceprocess.html",
    "title": "ZebraPuma.System.ServiceProcess | ZebraPuma Documentation",
    "summary": "ZebraPuma.System.ServiceProcess Gestion Avancée des Services Windows avec Support Plugins \uD83D\uDCCB Table des Matières Vue d'ensemble Architecture Interfaces et Classes ServiceManager ServiceControllerForm Configuration Utilisation Exemples API Référence Déploiement Windows Bonnes Pratiques Vue d'ensemble ZebraPuma.System.ServiceProcess est une bibliothèque avancée pour créer et gérer des services Windows extensibles en .NET. Elle combine le framework de services Windows natif avec le système de plugins ZebraPuma pour créer des services modulaires et maintenables. Caractéristiques Principales ✅ Services Windows étendus avec interface IServiceExtended ✅ Classe de base ServiceBaseExtended thread-safe ✅ ServiceManager pour gérer plusieurs services simultanément ✅ Interface WinForms de contrôle (ServiceControllerForm) ✅ Intégration complète avec ZebraPuma.Plugins ✅ Support multi-frameworks avec adaptation automatique ✅ Mode console pour développement et debugging ✅ Mode service pour production Windows ✅ Rechargement dynamique des services Cibles Supportées .NET Framework 4.8 (Windows) .NET 10.0-windows Dépendances ZebraPuma.Plugins (projet référencé) Newtonsoft.Json 13.0.4 NLog 6.0.7 System.ServiceProcess (pour .NET Framework 4.8) System.ServiceProcess.ServiceController 9.0.0 (pour .NET 10.0) Architecture Diagramme de Classes ┌─────────────────────────────────────────────────────────┐ │ Windows Service Host │ │ │ │ ┌────────────────────────────────────────────────────┐ │ │ │ ServiceManager │ │ │ │ • Services: List<IServiceExtended> │ │ │ │ • StartService(name) │ │ │ │ • StopService(name) │ │ │ │ • StartAll() / StopAll() │ │ │ │ • ReloadFromPlugins() │ │ │ │ • Events: ServiceStateChanged, ServicesReloaded │ │ │ └────────────────────────────────────────────────────┘ │ │ │ │ │ ┌───────────────┴────────────┐ │ │ ▼ ▼ │ │ ┌──────────────┐ ┌──────────────┐ │ │ │ IServiceExt. │ │ServiceFactory│ │ │ │ + IPlugin │ │ LoadServices │ │ │ └──────────────┘ └──────────────┘ │ │ │ │ └──────────┼───────────────────────────────────────────────┘ │ ▼ ┌────────────────────────────────────────┐ │ ServiceBaseExtended │ │ : ServiceBase, IServiceExtended │ │ │ │ • OnStart(args) → OnStartCore(args) │ │ • OnStop() → OnStopCore() │ │ • StartService() / StopService() │ │ • IsRunning (thread-safe) │ │ • Lock-based synchronization │ └────────────────────────────────────────┘ │ ▼ ┌────────────────────────────────────────┐ │ Votre Service Concret │ │ │ │ protected override OnStartCore() │ │ protected override OnStopCore() │ └────────────────────────────────────────┘ Flux d'Exécution Mode Service Windows 1. Windows SCM lance le service ↓ 2. OnStart() appelé automatiquement ↓ 3. ServiceBaseExtended.OnStart() → StartInternal() ↓ 4. Lock acquisition ↓ 5. OnStartCore() de votre service ↓ 6. IsRunning = true ↓ 7. Service en cours d'exécution ↓ 8. Windows SCM demande l'arrêt ↓ 9. OnStop() → StopInternal() ↓ 10. OnStopCore() de votre service ↓ 11. IsRunning = false Mode Console (Debug) 1. Application console démarre ↓ 2. ServiceManager.CreateFromPlugins() ↓ 3. Chargement des services via PluginLoader ↓ 4. ServiceControllerForm.Show() (optionnel) ↓ 5. manager.StartAll() ou StartService(name) ↓ 6. Services s'exécutent ↓ 7. manager.StopAll() avant exit Interfaces et Classes IServiceExtended Interface étendant IPlugin avec les capacités de service Windows. public interface IServiceExtended : IPlugin { /// <summary> /// Démarre le service Windows. /// </summary> void StartService(); /// <summary> /// Arrête le service Windows. /// </summary> void StopService(); /// <summary> /// Indique si le service est actuellement en cours d'exécution. /// </summary> bool IsRunning { get; } } ServiceBaseExtended Classe de base abstraite pour créer des services Windows. public abstract class ServiceBaseExtended : ServiceBase, IServiceExtended { // Propriétés héritées de IPlugin public abstract string Name { get; } public virtual string Version { get; } public virtual string Description { get; } // Propriété de IServiceExtended public bool IsRunning { get; } // Méthodes publiques public void StartService(); public void StopService(); public virtual void Initialize(IPluginContext context); // Méthodes abstraites à implémenter protected abstract void OnStartCore(string[] args); protected abstract void OnStopCore(); // Pattern Dispose protected virtual void DisposeManagedResources(); protected virtual void DisposeUnmanagedResources(); } Caractéristiques : Thread-safe : Utilise un lock pour synchroniser Start/Stop Gestion d'état : IsRunning volatile pour lecture thread-safe Sealed overrides : OnStart() et OnStop() sont sealed, vous devez override OnStartCore() et OnStopCore() Exception safety : Si OnStartCore() lève une exception, IsRunning reste false ServiceManager Gestionnaire centralisé pour administrer plusieurs services. public class ServiceManager : IDisposable { // Constructeurs public ServiceManager(IServiceExtended service); public ServiceManager(List<IServiceExtended> services); // Factory methods public static ServiceManager CreateFromPlugins(PluginLoadingOptions options = null); // Propriétés public IList<IServiceExtended> Services { get; } // Méthodes de contrôle public void StartService(string name); public void StopService(string name); public void RestartService(string name); public void StartAll(); public void StopAll(); public void ReloadFromPlugins(PluginLoadingOptions options = null); // Événements public event EventHandler<ServiceStateChangedEventArgs> ServiceStateChanged; public event EventHandler ServicesReloaded; } ServiceFactory Factory pour créer des services depuis une configuration JSON. public class ServiceFactory { public List<IServiceExtended> LoadServices(string configPath); } ServiceDefinition Classe de configuration pour définir un service. public class ServiceDefinition { public string Name { get; set; } public string Type { get; set; } public string Description { get; set; } } ServiceManager Le ServiceManager est le composant central pour gérer plusieurs services. Création Depuis des plugins : var manager = ServiceManager.CreateFromPlugins(new PluginLoadingOptions { PluginsDirectoryName = \"Services\", ConfigFileName = \"services.json\" }); Avec une liste de services : var services = new List<IServiceExtended> { new MonService1(), new MonService2() }; var manager = new ServiceManager(services); Contrôle des Services // Démarrer un service spécifique manager.StartService(\"MonService1\"); // Arrêter un service manager.StopService(\"MonService1\"); // Redémarrer manager.RestartService(\"MonService1\"); // Démarrer tous les services manager.StartAll(); // Arrêter tous les services manager.StopAll(); Rechargement Dynamique // Recharger les services depuis les plugins manager.ReloadFromPlugins(); // Événement déclenché après rechargement manager.ServicesReloaded += (sender, args) => { Console.WriteLine(\"Services rechargés\"); }; Événements manager.ServiceStateChanged += (sender, args) => { Console.WriteLine($\"Service {args.ServiceName}: {(args.IsRunning ? \"Démarré\" : \"Arrêté\")}\"); }; ServiceControllerForm Interface graphique WinForms pour contrôler les services. Utilisation var manager = ServiceManager.CreateFromPlugins(); var form = new ServiceControllerForm(manager); form.ShowDialog(); Fonctionnalités ✅ Liste tous les services avec leur état ✅ Boutons Start/Stop/Restart par service ✅ Bouton Start All / Stop All ✅ Bouton Reload pour recharger les plugins ✅ Refresh automatique de l'interface ✅ Gestion d'erreurs avec MessageBox Configuration services.json Structure pour ServiceFactory : [ { \"Name\": \"MonService1\", \"Type\": \"MonApp.Services.MonService1, MonApp.Services\", \"Description\": \"Premier service\" }, { \"Name\": \"MonService2\", \"Type\": \"MonApp.Services.MonService2, MonApp.Services\", \"Description\": \"Deuxième service\" } ] plugins.json Pour utiliser avec PluginLoader : { \"AutoDiscover\": true, \"Plugins\": [ { \"Folder\": \"MonService\", \"Assembly\": \"MonService.dll\", \"Type\": \"MonApp.Services.MonService\" } ] } NLog.config Logging structuré pour les services : <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <targets> <target name=\"file\" xsi:type=\"File\" fileName=\"${basedir}/logs/${shortdate}.log\" layout=\"${longdate} ${uppercase:${level}} ${logger} ${message} ${exception:format=tostring}\" /> <target name=\"eventlog\" xsi:type=\"EventLog\" source=\"MonService\" log=\"Application\" layout=\"${message} ${exception:format=tostring}\" /> </targets> <rules> <logger name=\"*\" minlevel=\"Info\" writeTo=\"file\" /> <logger name=\"*\" minlevel=\"Error\" writeTo=\"eventlog\" /> </rules> </nlog> Utilisation Scénario 1 : Service Simple Étape 1 : Créer le Service using System; using System.Threading; using NLog; using ZebraPuma.Plugins; using ZebraPuma.System.ServiceProcess; namespace MonApp.Services { public class HeartbeatService : ServiceBaseExtended { private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); private Timer _timer; public override string Name => \"HeartbeatService\"; public override string Description => \"Service envoyant un heartbeat toutes les 10 secondes\"; protected override void OnStartCore(string[] args) { Logger.Info(\"Démarrage de {Service}\", Name); _timer = new Timer(OnTick, null, TimeSpan.Zero, TimeSpan.FromSeconds(10)); } protected override void OnStopCore() { Logger.Info(\"Arrêt de {Service}\", Name); _timer?.Change(Timeout.Infinite, Timeout.Infinite); _timer?.Dispose(); _timer = null; } private void OnTick(object state) { Logger.Debug(\"Heartbeat à {Time}\", DateTime.Now); } protected override void DisposeManagedResources() { _timer?.Dispose(); } } } Étape 2 : Mode Console (Debug) using System; using ZebraPuma.System.ServiceProcess; namespace MonApp { class Program { static void Main(string[] args) { if (Environment.UserInteractive) { // Mode console pour développement var service = new HeartbeatService(); service.StartService(); Console.WriteLine(\"Service démarré. Appuyez sur Enter pour arrêter...\"); Console.ReadLine(); service.StopService(); service.Dispose(); } else { // Mode service Windows var servicesToRun = new ServiceBase[] { new HeartbeatService() }; ServiceBase.Run(servicesToRun); } } } } Étape 3 : Installation Windows # En tant qu'administrateur # Créer le service sc create HeartbeatService binPath=\"C:\\MonApp\\MonApp.exe\" DisplayName=\"Heartbeat Service\" # Configurer le démarrage automatique sc config HeartbeatService start=auto # Démarrer le service sc start HeartbeatService # Vérifier l'état sc query HeartbeatService Scénario 2 : Multi-Services avec ServiceManager Programme Principal using System; using System.ServiceProcess; using ZebraPuma.Plugins; using ZebraPuma.System.ServiceProcess; namespace MonApp { class Program { static void Main(string[] args) { if (Environment.UserInteractive) { RunInConsoleMode(); } else { RunAsWindowsService(); } } static void RunInConsoleMode() { var manager = ServiceManager.CreateFromPlugins(new PluginLoadingOptions { PluginsDirectoryName = \"Services\", ConfigFileName = \"plugins.json\" }); // Afficher l'interface de contrôle var form = new ServiceControllerForm(manager); form.ShowDialog(); // Cleanup manager.StopAll(); manager.Dispose(); } static void RunAsWindowsService() { // Charger les services var services = PluginLoader.LoadPlugins<IServiceExtended>(new PluginLoadingOptions { PluginsDirectoryName = \"Services\" }); // Convertir en ServiceBase[] var serviceBases = services .OfType<ServiceBase>() .ToArray(); if (serviceBases.Any()) { ServiceBase.Run(serviceBases); } } } } Scénario 3 : Service avec Configuration Configuration (heartbeatservice.json) { \"IntervalSeconds\": 30, \"LogToFile\": true, \"LogToEventLog\": false, \"Endpoints\": [ \"https://api1.example.com/ping\", \"https://api2.example.com/ping\" ] } Classe de Configuration public class HeartbeatServiceConfig { public int IntervalSeconds { get; set; } = 10; public bool LogToFile { get; set; } = true; public bool LogToEventLog { get; set; } = false; public List<string> Endpoints { get; set; } = new List<string>(); } Service avec Configuration using ZebraPuma.Plugins; using ZebraPuma.System.ServiceProcess; public class HeartbeatService : ServiceBaseExtended { private HeartbeatServiceConfig _config; private Timer _timer; public override string Name => \"HeartbeatService\"; public override void Initialize(IPluginContext context) { base.Initialize(context); // Charger la configuration _config = PluginConfigLoader.LoadAssemblyConfig<HeartbeatServiceConfig>(); Logger.Info(\"Configuration chargée: Intervalle={Seconds}s, Endpoints={Count}\", _config.IntervalSeconds, _config.Endpoints.Count); } protected override void OnStartCore(string[] args) { var interval = TimeSpan.FromSeconds(_config.IntervalSeconds); _timer = new Timer(OnTick, null, TimeSpan.Zero, interval); } private void OnTick(object state) { foreach (var endpoint in _config.Endpoints) { try { // Ping l'endpoint using (var client = new HttpClient()) { var response = client.GetAsync(endpoint).Result; Logger.Debug(\"Ping {Endpoint}: {Status}\", endpoint, response.StatusCode); } } catch (Exception ex) { Logger.Error(ex, \"Erreur ping {Endpoint}\", endpoint); } } } protected override void OnStopCore() { _timer?.Dispose(); } } Exemples Exemple 1 : Service de Traitement de Queue using System.Collections.Concurrent; using System.Threading; using System.Threading.Tasks; using ZebraPuma.System.ServiceProcess; public class QueueProcessorService : ServiceBaseExtended { private readonly ConcurrentQueue<string> _queue = new ConcurrentQueue<string>(); private CancellationTokenSource _cts; private Task _processingTask; public override string Name => \"QueueProcessor\"; protected override void OnStartCore(string[] args) { _cts = new CancellationTokenSource(); _processingTask = Task.Run(() => ProcessQueue(_cts.Token)); Logger.Info(\"Queue processor démarré\"); } protected override void OnStopCore() { _cts?.Cancel(); _processingTask?.Wait(TimeSpan.FromSeconds(30)); Logger.Info(\"Queue processor arrêté\"); } private async Task ProcessQueue(CancellationToken ct) { while (!ct.IsCancellationRequested) { if (_queue.TryDequeue(out string item)) { await ProcessItem(item); } else { await Task.Delay(100, ct); } } } private async Task ProcessItem(string item) { Logger.Debug(\"Traitement de {Item}\", item); await Task.Delay(1000); // Simule le traitement } public void Enqueue(string item) { _queue.Enqueue(item); } protected override void DisposeManagedResources() { _cts?.Dispose(); _processingTask?.Dispose(); } } Exemple 2 : Service de Monitoring avec Alertes using System; using System.Diagnostics; using System.Threading; using ZebraPuma.System.ServiceProcess; public class SystemMonitorService : ServiceBaseExtended { private Timer _timer; private PerformanceCounter _cpuCounter; private PerformanceCounter _ramCounter; public override string Name => \"SystemMonitor\"; public override string Description => \"Surveillance du CPU et de la RAM\"; protected override void OnStartCore(string[] args) { _cpuCounter = new PerformanceCounter(\"Processor\", \"% Processor Time\", \"_Total\"); _ramCounter = new PerformanceCounter(\"Memory\", \"Available MBytes\"); _timer = new Timer(CheckSystem, null, TimeSpan.Zero, TimeSpan.FromMinutes(1)); Logger.Info(\"Monitoring système démarré\"); } private void CheckSystem(object state) { var cpu = _cpuCounter.NextValue(); var ram = _ramCounter.NextValue(); Logger.Info(\"CPU: {Cpu:F2}%, RAM disponible: {Ram:F0} MB\", cpu, ram); // Alertes if (cpu > 90) { Logger.Warn(\"⚠️ CPU élevé: {Cpu:F2}%\", cpu); SendAlert($\"CPU critique: {cpu:F2}%\"); } if (ram < 500) { Logger.Warn(\"⚠️ RAM faible: {Ram:F0} MB\", ram); SendAlert($\"RAM critique: {ram:F0} MB\"); } } private void SendAlert(string message) { // Envoyer email, SMS, etc. Logger.Error(\"ALERTE: {Message}\", message); } protected override void OnStopCore() { _timer?.Dispose(); _cpuCounter?.Dispose(); _ramCounter?.Dispose(); Logger.Info(\"Monitoring système arrêté\"); } } API Référence Namespace: ZebraPuma.System.ServiceProcess Classes Classe Description ServiceBaseExtended Classe de base pour services Windows ServiceManager Gestionnaire multi-services ServiceFactory Factory pour créer des services ServiceControllerForm Interface WinForms de contrôle ServiceDefinition Définition de configuration de service Interfaces Interface Description IServiceExtended Contrat pour services Windows étendus Events Event Args Description ServiceStateChanged ServiceStateChangedEventArgs Service démarré/arrêté ServicesReloaded EventArgs Services rechargés Déploiement Windows Installation d'un Service # Méthode 1 : sc.exe (recommandé) sc create \"MonService\" ` binPath=\"C:\\MonApp\\MonService.exe\" ` DisplayName=\"Mon Service ZebraPuma\" ` start=auto ` obj=\"LocalSystem\" # Méthode 2 : PowerShell New-Service -Name \"MonService\" ` -BinaryPathName \"C:\\MonApp\\MonService.exe\" ` -DisplayName \"Mon Service ZebraPuma\" ` -StartupType Automatic # Méthode 3 : InstallUtil (legacy) InstallUtil.exe C:\\MonApp\\MonService.exe Configuration du Service # Changer le compte de démarrage sc config MonService obj=\"DOMAIN\\ServiceAccount\" password=\"P@ssw0rd\" # Définir la description sc description MonService \"Service de traitement ZebraPuma\" # Configurer la récupération sur échec sc failure MonService reset=86400 actions=restart/5000/restart/10000/restart/30000 Contrôle du Service # Démarrer Start-Service MonService # ou sc start MonService # Arrêter Stop-Service MonService # ou sc stop MonService # Redémarrer Restart-Service MonService # Vérifier l'état Get-Service MonService # ou sc query MonService Désinstallation # Arrêter d'abord Stop-Service MonService # Supprimer sc delete MonService # ou Remove-Service MonService Bonnes Pratiques 1. Thread Safety ✅ Bon - Utiliser des CancellationToken private CancellationTokenSource _cts; protected override void OnStartCore(string[] args) { _cts = new CancellationTokenSource(); Task.Run(() => DoWork(_cts.Token), _cts.Token); } protected override void OnStopCore() { _cts?.Cancel(); } 2. Timeout sur OnStopCore ✅ Bon - Toujours implémenter un timeout protected override void OnStopCore() { _cts?.Cancel(); if (!_task.Wait(TimeSpan.FromSeconds(30))) { Logger.Warn(\"Timeout lors de l'arrêt\"); } } 3. Logging Structuré ✅ Bon Logger.Info(\"Service {Name} démarré avec {Count} workers\", Name, workerCount); Logger.Error(ex, \"Erreur lors du traitement de {Item}\", item); 4. Gestion d'Erreurs ✅ Bon protected override void OnStartCore(string[] args) { try { // Initialisation critique InitializeDatabase(); } catch (Exception ex) { Logger.Fatal(ex, \"Échec d'initialisation critique\"); throw; // Laisser remonter pour que IsRunning reste false } } 5. Ressources ✅ Bon protected override void DisposeManagedResources() { _timer?.Dispose(); _connection?.Close(); _connection?.Dispose(); } ⬅️ Retour à la documentation principale"
  },
  "index.html": {
    "href": "index.html",
    "title": "Zebra Puma Framework | ZebraPuma Documentation",
    "summary": "Zebra Puma Framework Services & Plugins pour Windows et .NET \uD83D\uDCDA Vue d'ensemble ZebraPuma est un framework d'entreprise conçu pour faciliter le développement d'applications modulaires, de services Windows et d'outils d'analyse de données. Le framework offre une architecture extensible basée sur des plugins, permettant une grande flexibilité et une maintenance simplifiée. Auteur Régis SCYEUR - Zebra Puma Services Copyright © 2025-2026 Régis SCYEUR - Zebra Puma Services - Tous droits réservés Licence Licence Propriétaire - Voir le fichier LICENSE \uD83C\uDFD7️ Architecture de la Solution La solution ZebraPuma est organisée en plusieurs bibliothèques réutilisables et applications : \uD83D\uDCE6 Composants Principaux Composant Type Description Cibles ZebraPuma.Plugins Bibliothèque Système de plugins modulaire avec chargement dynamique .NET 4.8, .NET 10.0 ZebraPuma.System.ServiceProcess Bibliothèque Gestion avancée des services Windows avec support plugins .NET 4.8, .NET 10.0-windows \uD83D\uDCD6 Documentation Détaillée Bibliothèques Core ZebraPuma.Plugins - Système de plugins avec chargement dynamique Architecture plugin/host Chargement automatique et manuel Gestion du cycle de vie Résolution des dépendances ZebraPuma.System.ServiceProcess - Services Windows extensibles Services basés sur plugins Interface de contrôle WinForms Gestion centralisée multi-services Support .NET Framework et .NET moderne \uD83D\uDE80 Démarrage Rapide Prérequis Windows 10 ou supérieur .NET Framework 4.8 pour les applications .NET Framework .NET 10.0 SDK pour les applications .NET modernes Visual Studio 2022 (recommandé) ou Visual Studio Code Installation Cloner le dépôt : git clone https://github.com/ZebraPumaOrg/ZebraPuma.git cd ZebraPuma Ouvrir la solution : cd src\\dotnet start ZebraPuma.sln Restaurer les packages NuGet : dotnet restore Compiler la solution : dotnet build Utilisation de Base Créer un Plugin Simple using ZebraPuma.Plugins; public class MonPlugin : PluginBase { public override string Name => \"MonPlugin\"; public override string Description => \"Un exemple de plugin\"; public override void Initialize(IPluginContext context) { base.Initialize(context); // Logique d'initialisation } } Charger des Plugins var plugins = PluginLoader.LoadPlugins<IPlugin>(); foreach (var plugin in plugins) { Console.WriteLine($\"Plugin chargé: {plugin.Name} v{plugin.Version}\"); } Créer un Service Windows using ZebraPuma.System.ServiceProcess; public class MonService : ServiceBaseExtended { public override string Name => \"MonService\"; protected override void OnStartCore(string[] args) { // Logique de démarrage } protected override void OnStopCore() { // Logique d'arrêt } } \uD83D\uDCC1 Structure du Projet ZebraPuma/ ├── docs/ # Documentation complète │ ├── README.md # Ce fichier │ ├── plugins.md # Doc ZebraPuma.Plugins │ ├── serviceprocess.md # Doc ZebraPuma.System.ServiceProcess │ └── examples/ # Exemples de code ├── src/ │ └── dotnet/ │ ├── ZebraPuma.sln # Solution Visual Studio │ ├── Directory.Build.props # Configuration partagée │ ├── ZebraPuma.Plugins/ # Bibliothèque de plugins │ ├── ZebraPuma.System.ServiceProcess/ # Bibliothèque de services │ └── (autres projets internes) ├── LICENSE # Licence propriétaire └── README.md # README principal \uD83D\uDD27 Configuration Configuration des Plugins (plugins.json) { \"AutoDiscover\": true, \"Plugins\": [ { \"Folder\": \"MonPlugin\", \"Assembly\": \"MonPlugin.dll\", \"Type\": \"MonNamespace.MonPlugin\" } ] } Configuration NLog Chaque bibliothèque inclut une configuration NLog pour le logging : <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <targets> <target name=\"file\" xsi:type=\"File\" fileName=\"${basedir}/logs/${shortdate}.log\" /> </targets> <rules> <logger name=\"*\" minlevel=\"Info\" writeTo=\"file\" /> </rules> </nlog> \uD83D\uDD0C Dépendances Packages NuGet Communs Newtonsoft.Json 13.0.4 - Sérialisation JSON NLog 6.0.7 - Logging structuré Packages Spécifiques ZebraPuma.System.ServiceProcess System.ServiceProcess.ServiceController 9.0.0 (.NET 10.0 uniquement) \uD83D\uDCCA Fonctionnalités Principales ZebraPuma.Plugins ✅ Chargement dynamique de plugins depuis DLL ✅ Auto-découverte des plugins dans les dossiers ✅ Configuration JSON flexible ✅ Résolution automatique des dépendances d'assemblies ✅ Gestion du cycle de vie (Initialize, Dispose) ✅ Support multi-frameworks (.NET 4.8 et .NET 10.0) ZebraPuma.System.ServiceProcess ✅ Services Windows étendus avec interface IServiceExtended ✅ Classe de base ServiceBaseExtended thread-safe ✅ ServiceManager pour gérer plusieurs services ✅ Interface WinForms de contrôle (ServiceControllerForm) ✅ Intégration avec le système de plugins ✅ Support multi-frameworks avec Windows Forms \uD83D\uDEE0️ Compilation et Déploiement Compilation en Ligne de Commande # Compiler toute la solution dotnet build src\\dotnet\\ZebraPuma.sln --configuration Release # Compiler un projet spécifique dotnet build src\\dotnet\\ZebraPuma.Plugins\\ZebraPuma.Plugins.csproj # Créer les packages NuGet dotnet pack src\\dotnet\\ZebraPuma.Plugins\\ZebraPuma.Plugins.csproj --configuration Release Publication # Publier pour .NET Framework 4.8 dotnet publish src\\dotnet\\ZebraPuma.System.ServiceProcess\\ZebraPuma.System.ServiceProcess.csproj ` --configuration Release ` --framework net48 ` --output publish\\net48 \uD83D\uDCDD Bonnes Pratiques Développement de Plugins Héritage de PluginBase : Utiliser PluginBase pour bénéficier du pattern Dispose Nom unique : Chaque plugin doit avoir un nom unique Versioning : Suivre le versioning sémantique (SemVer) Logging : Utiliser NLog pour tracer les opérations Configuration : Utiliser PluginConfigLoader pour charger la configuration Développement de Services Thread Safety : Les services doivent être thread-safe Gestion d'erreurs : Capturer et logger toutes les exceptions Timeout : Implémenter des timeouts pour les opérations longues État : Maintenir un état cohérent (IsRunning) Cleanup : Libérer toutes les ressources dans OnStopCore \uD83D\uDD0D Debugging et Troubleshooting Logs Les logs sont générés dans le dossier logs/ de chaque application : {Application}/logs/{date}.log Problèmes Courants Le plugin ne se charge pas Vérifier que le fichier plugins.json existe Vérifier que le chemin Assembly est correct Consulter les logs NLog Service ne démarre pas Vérifier les permissions Windows Vérifier que OnStartCore ne lève pas d'exception Consulter l'Event Viewer Windows Erreur de résolution d'assembly Vérifier que toutes les DLL dépendantes sont présentes Utiliser Fusion Log Viewer pour diagnostiquer \uD83E\uDDEA Tests Tests Unitaires # Exécuter tous les tests dotnet test src\\dotnet\\ZebraPuma.sln # Tests avec couverture dotnet test --collect:\"XPlat Code Coverage\" \uD83D\uDCC8 Roadmap Version 2.1 (Q1 2026) [ ] Support .NET 11.0 [ ] Amélioration du hot-reload des plugins [ ] Interface de configuration web Version 2.2 (Q2 2026) [ ] Support Linux pour les bibliothèques core [ ] Plugin manager GUI [ ] Métriques et monitoring intégrés \uD83E\uDD1D Contribution Ce projet est sous licence propriétaire. Les contributions externes ne sont pas acceptées sans accord commercial préalable. Pour toute question commerciale : Email : contact@zebrapuma.services GitHub : https://github.com/ZebraPumaOrg \uD83D\uDCDC Historique des Versions v2.0.x (Décembre 2025) Migration depuis EuroJapan vers ZebraPuma Support multi-frameworks (.NET 4.8 et .NET 10.0) Refactoring complet de l'architecture Documentation complète v1.0.x (2024) Version initiale dans le projet EuroJapan Support .NET Framework uniquement \uD83D\uDD17 Liens Utiles Site Web ZebraPuma GitHub Organization Packages ZebraPuma Packages NuGet publics Documentation API Licence Made with ❤️ by Régis SCYEUR, Zebra Puma Services"
  }
}